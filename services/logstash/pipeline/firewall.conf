
input {
    syslog {
       port => 6000 
    }
}

# Getting type and category of event
filter {

    grok {
        match => {
            "message" => "^%{DATA:categories} %{WORD:prefix}:"
        }
        tag_on_failure => ["no_category"]
    }

    if [categories] {

        mutate {
            split => {
                "[categories]" => ","
            }
        }

        mutate {
            rename => {
                "[prefix]"      => "[event][prefix]"
                "[categories]"  => "[event][category]"
            }
        }
    }
}

# Firewall events
filter {
    if "firewall" in [event][category]  {

        mutate { add_tag => ["firewall"] }

        # When firewall srcnat
        if [message] =~ /\: firewall srcnat\:/
        {    
            grok {
                match => {
                    "message" => "^%{GREEDYDATA}srcnat: in:%{DATA:in_interface} out:%{DATA:out_interface}, connection-state:%{DATA:connection_state} proto %{DATA:protocol}, %{IP:source_ip}:%{INT:source_port}->%{IP:destination_ip}:%{INT:destination_port}, len %{INT:length}"
                }
                add_tag => ["srcnat", "parsed"]
                tag_on_failure => ["srcnat_parse_error"]
            }
        }

        # When firewall input
        if [message] =~ /\: firewall input\:/ {
            grok {
                match => {
                    "message" => "^%{GREEDYDATA}input: in:%{DATA:in_interface} out:%{DATA:out_interface}, connection-state:%{DATA:connection_state} proto %{DATA:protocol}, %{IP:source_ip}:%{INT:source_port}->%{IP:destination_ip}:%{INT:destination_port}, len %{INT:length}"
                }
                add_tag => ["input", "parsed"]
                tag_on_failure => ["input_parse_error"]
            }
        }

        
        mutate {
            rename => {
                "[in_interface]"        => "[interface][input]"
                "[out_interface]"       => "[interface][output]"
                "[connection_state]"    => "[connection][state]"
                "[protocol]"            => "[connection][protocol]"
                "[source_ip]"           => "[source][ip]"
                "[source_port]"         => "[source][port]"
                "[destination_ip]"      => "[destination][ip]"
                "[destination_port]"    => "[destination][port]"
                "[length]"              => "[packet][length]"
            }
        }

        if [connection][protocol] =~ /TCP/ {
            translate {
                source => "[destination][port]"
                target => "[event][type]"
                dictionary => {
                    "22"    => "SSH"
                    "80"    => "HTTP"
                    "443"   => "HTTPS"
                    "3389"  => "RDP"
                }
            }
        }
        else if [connection][protocol] =~ /UDP/ {
            translate {
                source => "[destination][port]"
                target => "[event][type]"
                dictionary => {
                    "53"    => "DNS"
                }
            }
        }

        # Add to event destination.dns (if cached)
        ruby {
            path => "/usr/share/logstash/scripts/dns_enrichment.rb"
        }

    }
}

# DNS Events
filter {
    if "dns" in [event][category] and "packet" in [event][category] {
        # When DNS resolving event
        if [event][original] =~ /.*: <.*>/ {
            grok {
                match => {
                    "[event][original]" => "<%{DATA:query}.:%{DATA:type}:5=%{DATA:result}\.?>"
                }
                add_tag => ["dns", "resolve", "parsed"]
                tag_on_failure => ["dns_resolve_parse_error"]
            }

            mutate {
                rename => {
                    "query"  => "[dns][query]"
                    "type"   => "[dns][type]"
                    "result" => "[dns][resolved]"
                }
            }

            # If IN A - Cache record
            if [dns][type] == "A" {
                ruby {
                    path => "/usr/share/logstash/scripts/dns_cache.rb"
                }
            }

        }
    }
}


output {
    # stdout {}
    if "parsed" in [tags] {
        opensearch {
            hosts => ["https://192.168.40.135:9200"]
            user => "admin"
            password => "Opensearch1!"
            ssl => true
            ssl_certificate_verification => false
            index => "firewall-%{+YYYY.MM.dd}"
            manage_template => false 
        }
    }
}

